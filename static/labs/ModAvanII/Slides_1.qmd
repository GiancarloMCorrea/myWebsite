---
title: "Modelos avanzados en evaluación de recursos pesqueros: Día 1"
author: 
   <br>Dr. Giancarlo M. Correa
institute:
   <br>Cousteau Consultant Group
format:
  revealjs:
    theme: simple
    logo: images/CGlogo1.png
    slide-number: 'c/t'
    css: myStyle.css
from: markdown+emoji
editor: visual
execute:
  echo: true
bibliography: "https://api.citedrive.com/bib/b63ac242-a77c-4816-9c27-fcdfb31875b0/references.bib?x=eyJpZCI6ICJiNjNhYzI0Mi1hNzdjLTQ4MTYtOWMyNy1mY2RmYjMxODc1YjAiLCAidXNlciI6ICI1NDQwIiwgInNpZ25hdHVyZSI6ICIyMTMxYjVhZDk1NGYxNDUzYjk3YjZiNjk3ZDIxZWEwODIwZjA4MTBiZTk3YWIxOTNiMGVkMzI1YzI0YTRjZWNkIn0=/bibliography.bib"
---

# Modelos estructurados por edad

## Sistema pesquero

¿Para qué nos sirven los modelos de evaluación?

![](images/D1_img0.jpg){fig-align="center" width="70%"}

## Conceptos básicos

![](images/D1_img1.png){fig-align="center" width="100%"}

::: {.absolute top="650" left="70"}
::: sectionhead
[Stockholm University Baltic Sea Centre]{style="font-size:50%"}
:::
:::

## Conceptos básicos

<br>

Diferencias claves en enfoques para estudiar poblaciones:

![](images/D1_img2.png){fig-align="center" width="70%"}

::: {.absolute top="650" left="70"}
::: sectionhead
@Haddon_2011
:::
:::

## Enfoque integrado

Combina diferentes tipos de datos en un único análisis. El ajuste a los datos se realiza por medio de una rutina de minimización de alguna función objetivo [@Fournier_1982].

::: fragment
Tipos de datos más comunes:

-   Capturas
-   Índices de abundancia
-   Composición por tallas o edades
-   Marcaje y recaptura
:::

## Enfoque integrado

<br>

![](images/D1_img3.png){fig-align="center" width="60%"}

::: {.absolute top="650" left="70"}
::: sectionhead
@Haddon_2011
:::
:::

## Conceptos básicos

<br>

En un modelo de evaluación estructurado por edades tenemos los siguientes componentes principalmente:

-   Reclutamiento
-   Mortalidad (natural y por pesca)
-   Selectividad
-   Crecimiento somático

## Plataforma de evaluación

Software o librería orientado a la implementación de modelos de evaluación de stocks (en general).

::: fragment
::: {.callout-note icon="false"}
## Ventajas

-   No hay necesidad de codificar
-   Comunicación más sencilla
:::

::: {.callout-warning icon="false"}
## Desventajas

-   No pueden ser aplicables a todos los stocks
-   Efecto de *caja negra*
:::
:::

## Plataforma de evaluación

<br>

Ejemplos:

-   Stock Synthesis [@Methot_2013]
-   MULTIFAN-CL [@fournier1998multifan]
-   SAM [@Nielsen_2014]
-   **WHAM** [@Stock_2021]

# Introducción a modelos *state-space*

## Modelos *state-space*

::: {.callout-tip icon="false"}
## Definición

-   SSM permiten diferenciar y separar variaciones en procesos de un sistema de los errores de observación.
:::

::: fragment
Podemos tener dos series temporales:

1.  Serie de procesos, o estados, que representan los cambios verdaderos en el sistema.
2.  Serie de observaciones que realizamos del sistema.

Los procesos cambian en el tiempo estocásticamente, lo que se conoce como variaciones en procesos (*process variation*).
:::

## Modelos *state-space*

-   $z_{t}$: estado en tiempo $t$ (e.g., abundancia de la población)
-   $y_{t}$: observaciones

![](images/D1_img4.png){fig-align="center" width="100%"}

@Auger_M_th__2021

## Modelos *state-space*

Normalmente se asume un proceso Markov (de primer orden) para modelar los estados:

$$z_t = \beta z_{t-1}+\epsilon_t$$

-   $\beta$: autocorrelación de estados en el tiempo
-   $\epsilon$: variación de procesos, donde:

$$\epsilon_t \sim N(0,\sigma_p^2)$$

$z_0$ puede ser tratado como un parámetro adicional.

## Modelos *state-space*

Para el caso de las observaciones, se asumen que estas son independientes, y se relacionan con los estados:

$$y_t = \alpha z_{t}+\eta_t$$

-   $\alpha$: parámetro que regula el sesgo entre observación y estado
-   $\eta$: error de observación, donde:

$$\eta_t \sim N(0,\sigma_o^2)$$

## Modelos *state-space*

Podemos caracterizar este modelo en términos de distribuciones de probabilidad:

$$g(y_t \mid z_{t}, \boldsymbol{\theta}_o)$$

$$f(z_t \mid z_{t-1}, \boldsymbol{\theta}_p)$$

para $t=1,...,T$, donde $f$ y $g$ son dos funciones de densidad de probabilidad normales, $\boldsymbol{\theta}_p$ y $\boldsymbol{\theta}_o$ son vectores de parámetros asociados con cada ecuación:

$$\boldsymbol{\theta}_p = (\beta, \sigma_p^2), \boldsymbol{\theta}_o = (\alpha,\sigma_o^2)$$

## Modelos *state-space*

Los [efectos fijos]{style="color:red;"} vienen a ser:

$$\boldsymbol{\theta} = (\boldsymbol{\theta}_p, \boldsymbol{\theta}_o, z_0)$$

::: fragment
Y los estados $z_t$ son tratados como [variables aleatorias]{style="color:red;"}.

Por lo tanto, los SSM se consideran estos modelos jerárquicos:

1.  Primer nivel: ecuación de observación
2.  Segundo nivel: ecuación de proceso
:::

## Modelos *state-space*

-   Aplicaciones a una gran variedad de campos de investigación.

::: fragment
-   Enfoque utilizado para analizar series de tiempo en ecología:
    -   movimiento de animales
    -   biologging
    -   datos de captura-recaptura
    -   epidemiología
    -   evaluación de stocks
:::

## SSM en evaluación de stocks

Enfoque presentado por @Sullivan_1992 y @Gudmundsson_1994.

::: fragment
Usualmente los estados $z_t$ vienen a ser variables como [@Aeberhard_2018]:

-   Abundancia a la edad
-   Reclutamiento
-   Mortalidad por pesca
-   Mortalidad natural
-   Selectividad
:::

## SSM en evaluación de stocks

En modelos de evaluación tradicionales se emplea el enfoque de *máxima verosimilitud penalizada* (PML) para modelar variaciones temporales en algún estado.

::: {.callout-important icon="false"}
## Ejemplo

Para modelar mortalidad por pesca, se separa la mortalidad por pesca anual y la selectividad a la edad:

$$F_{a,t} = f_t S_a \exp(\delta_{a,t})$$

Asumiendo que $\delta_{a,t} \sim N(0,\sigma_\delta^2)$. El enfoque PML **fija** $\sigma_\delta^2$ (penalty term) en el modelo a un valor subjetivo.
:::

::: fragment
Principal ventaja de SSM: estimación de $\sigma_\delta^2$.
:::

## SSM en evaluación de stocks

<br>

En la actualidad, TMB [@Kristensen_2016] es la principal plataforma para implementar SSM debido a su eficiencia para modelar efectos aleatorios.

::: fragment
-   Desarrollado a partir de *ADMB* [@Fournier_2012]
-   Usa la maquinaria de C++
-   Sencilla manipulación desde R
:::

# Laboratorio

## Software requerido

<br>

-   MS Excel
-   R [instalar](https://cran.r-project.org/)
-   RStudio [instalar](https://posit.co/download/rstudio-desktop/)
-   Rtools [instalar](https://cran.r-project.org/bin/windows/Rtools/rtools43/rtools.html)

## Instalación de librerías

<br>

Instalar `TMB`:

```{r eval=FALSE}
install.packages('TMB')
```

<br>

::: fragment
Para instalar WHAM, utilizaremos la versión que permite incluir datos de tallas:

```{r eval=FALSE}
remotes::install_github(repo = 'GiancarloMCorrea/wham', ref='growth', 
                        INSTALL_opts = c("--no-docs", "--no-multiarch", "--no-demo"))
```

También les sugiero explorar la [versión base de WHAM](https://timjmiller.github.io/wham/).
:::

## Modelo sencillo en TMB

<br>

Objetivo: Conocer los pasos para implementar un modelo en TMB

Ejemplo obtenido de [Sean Anderson](https://seananderson.ca/2014/10/17/tmb/) (Gompertz SSM).

## Modelo sencillo en TMB

1.  Tener en claro el sistema a modelar:

$$u_t = a + b u_{t-1} + \epsilon_t$$ $$y_t = ln(u_t)$$

$$\epsilon_t \sim N(0,\sigma_p^2)$$ $$y_t \sim N(ln(u_t),\sigma_o^2)$$

Donde $u_t$ es el estado (abundancia) en la población.

## Modelo sencillo en TMB

2.  Implementar tu modelo en TMB (ver `Ejercicio_1.cpp`)

```{Rcpp}
#| eval: false
#| code-line-numbers: "1-5"

// Header
#include <TMB.hpp>

template<class Type>
Type objective_function<Type>::operator() () {

// Input data:
DATA_VECTOR(y);

// Parameters (fixed and random variables):
PARAMETER(a); 
PARAMETER(b); 
PARAMETER(log_sigma_proc); 
PARAMETER(log_sigma_obs); 
PARAMETER_VECTOR(u); 

// Transformed parameters if required
Type sigma_proc = exp(log_sigma_proc);
Type sigma_obs = exp(log_sigma_obs);

// Reports on transformed parameters:
ADREPORT(sigma_proc)
ADREPORT(sigma_obs)

int n = y.size(); // get time series length

Type nll = 0.0; // initialize negative log likelihood

// process model:
for(int i = 1; i < n; i++){
  Type m = a + b * u[i - 1]; // Gompertz
  nll -= dnorm(u[i], m, sigma_proc, true); // nll function
}

// observation model:
for(int i = 0; i < n; i++){
  nll -= dnorm(y[i], u[i], sigma_obs, true); // nll function
}

return nll;
}
```

## Modelo sencillo en TMB

2.  Implementar tu modelo en TMB (ver `Ejercicio_1.cpp`)

```{Rcpp}
#| eval: false
#| code-line-numbers: "7-15"

// Header
#include <TMB.hpp>

template<class Type>
Type objective_function<Type>::operator() () {

// Input data:
DATA_VECTOR(y);

// Parameters (fixed and random variables):
PARAMETER(a); 
PARAMETER(b); 
PARAMETER(log_sigma_proc); 
PARAMETER(log_sigma_obs); 
PARAMETER_VECTOR(u); 

// Transformed parameters if required
Type sigma_proc = exp(log_sigma_proc);
Type sigma_obs = exp(log_sigma_obs);

// Reports on transformed parameters:
ADREPORT(sigma_proc)
ADREPORT(sigma_obs)

int n = y.size(); // get time series length

Type nll = 0.0; // initialize negative log likelihood

// process model:
for(int i = 1; i < n; i++){
  Type m = a + b * u[i - 1]; // Gompertz
  nll -= dnorm(u[i], m, sigma_proc, true); // nll function
}

// observation model:
for(int i = 0; i < n; i++){
  nll -= dnorm(y[i], u[i], sigma_obs, true); // nll function
}

return nll;
}
```

## Modelo sencillo en TMB

2.  Implementar tu modelo en TMB (ver `Ejercicio_1.cpp`)

```{Rcpp}
#| eval: false

// Header
#include <TMB.hpp>

template<class Type>
Type objective_function<Type>::operator() () {

// Input data:
DATA_VECTOR(y);

// Parameters (fixed and random variables):
PARAMETER(a); 
PARAMETER(b); 
PARAMETER(log_sigma_proc); 
PARAMETER(log_sigma_obs); 
PARAMETER_VECTOR(u); 

// Transformed parameters if required
Type sigma_proc = exp(log_sigma_proc);
Type sigma_obs = exp(log_sigma_obs);

// Reports on transformed parameters:
ADREPORT(sigma_proc)
ADREPORT(sigma_obs)

int n = y.size(); // get time series length

Type nll = 0.0; // initialize negative log likelihood

// process model:
for(int i = 1; i < n; i++){
  Type m = a + b * u[i - 1]; // Gompertz
  nll -= dnorm(u[i], m, sigma_proc, true); // nll function
}

// observation model:
for(int i = 0; i < n; i++){
  nll -= dnorm(y[i], u[i], sigma_obs, true); // nll function
}

return nll;
}
```

## Modelo sencillo en TMB

<br>

3.  Compilar el modelo (en R):

```{r eval = FALSE}
require(TMB)
compile("Ejercicio_1.cpp")
dyn.load(dynlib("Ejercicio_1"))
```

## Modelo sencillo en TMB

<br>

4.  En R, leer tus datos. Imaginemos que `y` son tus observaciones:

```{r echo = FALSE}
N = 100
seed = 123
sigma_obs = 0.2
sigma_proc = 0.2
a = 1.4
b = 0.7
y1 = 4

set.seed(seed)
N <- N
ytrue <- numeric(length = N)
ytrue[1] <- y1
log_sigma_proc <- log(sigma_proc)
proc_error <- rnorm(N, mean = 0, sd = sigma_proc)
log_sigma_obs <- log(sigma_obs)
for(i in 2:N) {
  ytrue[i] <- a + b * ytrue[i-1] + proc_error[i-1]
}
x <- seq_len(N)
y <- rnorm(N, mean = ytrue, sd = sigma_obs)
```

```{r}
print(y)
```

## Modelo sencillo en TMB

<br>

5.  Preparar los objetos y correr el modelo:

```{r eval = FALSE}
# Data input (list)
data <- list(y = y) 
# fixed effects and random variables (list):
parameters <- list(a = 1, b = 0.5, log_sigma_proc = -1,
                   log_sigma_obs = -1, u = rep(mean(y), 100))
# Construct objective function (define random variable):
obj <- MakeADFun(data, parameters, random = "u", DLL = "Ejercicio_1")
obj$hessian <- FALSE # no calculate hessian
# Optimization:
opt <- nlminb(start = obj$par, obj = obj$fn, gr = obj$gr)
# Calculate SD of model parameters
est_pars <- sdreport(obj)
```

## Modelo básico de evaluación de stocks

<br>

<br>

Abrir archivo `Ejercicio_2.xlsx`

## Referencias
