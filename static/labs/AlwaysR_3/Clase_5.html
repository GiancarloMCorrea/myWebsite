<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>AlwaysR, Módulo III: Estadística en R</title>
    <meta charset="utf-8" />
    <meta name="author" content="Giancarlo M. Correa" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link href="libs/remark-css/default.css" rel="stylesheet" />
    <link href="libs/remark-css/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">


class: inverse, center, middle

# AlwaysR, Módulo III: Estadística en R

## Clase 5: Introducción a modelos lineales y aditivos generalizados (GLM y GAM)

### Giancarlo M. Correa

&lt;img src="LOGO05.png" width="350px"/&gt;

---



class: inverse, center, middle

# Modelos lineales generalizados (GLM)

<div>
<style type="text/css">.xaringan-extra-logo {
width: 70px;
height: 128px;
z-index: 0;
background-image: url(LOGO06.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
bottom:-3em;left:0;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('a')
          logo.classList = 'xaringan-extra-logo'
          logo.href = 'https://cousteau-group.com/'
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>

---

# GLM

Un modelo lineal simple puede ser expresado como:

`$$y \sim N(\mu , \sigma^2)$$`

`$$\mu=\beta_0+\beta_1 x_1 + \beta_2 x_2 + ... + \beta_p x_p$$`

--

Un GLM es una opción cuando la varianza de la variable respuesta no es constante o no está normalmente distribuida.

--

GLM transforma la variable respuesta para que el método de estimación de parámetros siga *funcionando bien* (mediante una función *link*).

--

Al momento de implementar un GLM, debemos decidir dos cosas:

1. La distribución a utilizar
2. La función *link* (esto normalmente está por defecto en R).

`$$y \sim EDM(\mu, etc)$$`

`$$g(\mu) = \beta_0 + \sum_{j=1}^p \beta_j x_{j}$$`

---

# GLM

Por ejemplo, podemos tener:




```r
data(quilpie)
head(quilpie)
```

```
##   Year Rain   SOI Phase Exceed y
## 1 1921 38.4   2.7     2    Yes 1
## 2 1922  0.0   2.0     5     No 0
## 3 1923  0.0 -10.7     3     No 0
## 4 1924 24.4   6.9     2    Yes 1
## 5 1925  0.0 -12.5     3     No 0
## 6 1926  9.1  -1.0     4     No 0
```

Para este caso, si `y` es la variable respuesta, entonces podemos usar:

`$$y_i \sim Binom(\mu_i, m_i)$$`

`$$log\frac{\mu_i}{1-\mu_i} = \beta_0 + \beta_1 SOI_i$$`

---

# GLM: respuesta binaria

Para una variable de respuesta binaria (e.g. 0/1 - presencia/asusencia - hembra/macho), tipicamente la modelamos con una función *link* tipo *logit* y función de varianza `\(\mu (1-\mu)\)`. La respuesta modelada son las probabilidades de registro predichas (*predicted log odds*) del evento de interés.

--


```r
head(hsb)
```

```
##    id gender  race    ses schtyp     prog read write math science socst
## 1  70   male white    low public  general   57    52   41      47    57
## 2 121 female white middle public vocation   68    59   53      63    61
## 3  86   male white   high public  general   44    33   54      58    31
## 4 141   male white   high public vocation   63    44   47      53    56
## 5 172   male white middle public academic   47    52   57      53    61
## 6 113   male white middle public academic   44    52   51      63    61
```

--

Para este ejemplo, modelaremos el registro de `hsb$prog == academic`. 

---

# GLM: respuesta binaria

En R vamos a usar:


```r
hsb$obj_var = ifelse(test = hsb$prog == 'academic', yes = 1, no = 0)
mod1 = glm(obj_var ~ read, family = binomial, data = hsb)
```

--

Aquí, la variable respuesta es una variable indicadora (binaria):


```r
hsb$obj_var[1:20]
```

```
##  [1] 0 0 0 0 1 1 0 1 0 1 0 1 1 1 1 0 1 0 1 0
```

---


```r
summary(mod1)
```

```
## 
## Call:
## glm(formula = obj_var ~ read, family = binomial, data = hsb)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -1.8817  -1.0329   0.4935   1.0182   1.8654  
## 
## Coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -4.67739    0.90426  -5.173 2.31e-07 ***
## read         0.09207    0.01730   5.321 1.03e-07 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for binomial family taken to be 1)
## 
##     Null deviance: 276.76  on 199  degrees of freedom
## Residual deviance: 241.58  on 198  degrees of freedom
## AIC: 245.58
## 
## Number of Fisher Scoring iterations: 4
```


---

# GLM: respuesta binaria

Vemos un par de términos nuevos:

* **Null deviance**: nos indica que tan bien la variable respuesta puede ser predicha por un modelo que solo contenga el intercepto. 

* **Residual deviance**: nos indica que tan bien la variable respuesta es predicha por el modelo implementado. 

---

# GLM: respuesta binaria

La revisión de supuestos en un GLM no es tan sencilla. Podemos revisar la independencia de observaciones (especialmente importante cuando tenemos datos que vienen con posible dependencia temporal o espacial):


```r
plot(statmod::qresid(mod1))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-7-1.png" width="370" style="display: block; margin: auto;" /&gt;

---

# GLM: respuesta binaria

&lt;img src="images/fig27.png" width="600" style="display: block; margin: auto;" /&gt;


---

# GLM: respuesta binaria

Revisar los valores observados y ajustados:


```r
plot_model(model = mod1, type = 'pred', show.data = TRUE)
```

```
## $read
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-9-1.png" width="350" style="display: block; margin: auto;" /&gt;

---

# GLM: respuesta binaria

Revisar distribucion asumida:


```r
qqnorm(qresid(mod1))
qqline(qresid(mod1))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-10-1.png" width="400" style="display: block; margin: auto;" /&gt;


---

# GLM: respuesta binaria

Revisar observaciones influyentes:


```r
plot(cooks.distance(mod1), type='h')
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-11-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

# GLM: datos de conteo

Cuando tenemos una variable discreta (e.g. conteo de individuos, de especies, etc.), es recomendable implementar el modelo usando la familia de distribuciones Poisson. 



--


```r
head(cases)
```

```
##   Days Students
## 1    1        6
## 2    2        8
## 3    3       12
## 4    3        9
## 5    4        3
## 6    4        3
```

---

# GLM: datos de conteo

Exploremos la que será la variable respuesta en nuestro modelo:


```r
hist(cases$Students)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-14-1.png" width="400" style="display: block; margin: auto;" /&gt;


---


```r
mod2 = glm(Students ~ Days, family = poisson, data = cases)
summary(mod2)
```

```
## 
## Call:
## glm(formula = Students ~ Days, family = poisson, data = cases)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -2.00482  -0.85719  -0.09331   0.63969   1.73696  
## 
## Coefficients:
##              Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)  1.990235   0.083935   23.71   &lt;2e-16 ***
## Days        -0.017463   0.001727  -10.11   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for poisson family taken to be 1)
## 
##     Null deviance: 215.36  on 108  degrees of freedom
## Residual deviance: 101.17  on 107  degrees of freedom
## AIC: 393.11
## 
## Number of Fisher Scoring iterations: 5
```

---

# GLM: datos de conteo

Verificar independencia de residuos:


```r
plot(qresid(mod2))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-16-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

# GLM: datos de conteo

Revisar los valores observados y ajustados:


```r
plot_model(model = mod2, type = 'pred', show.data = TRUE)
```

```
## $Days
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-17-1.png" width="350" style="display: block; margin: auto;" /&gt;

---

# GLM: datos de conteo

Revisar distribucion asumida:


```r
qqnorm(qresid(mod2))
qqline(qresid(mod2))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-18-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

# GLM: datos de conteo

Revisar observaciones influyentes:


```r
plot(cooks.distance(mod2), type='h')
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-19-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

# GLM: datos de conteo con sobredispersión

Exploremos una nueva base de datos:





```r
head(disc)
```

```
##   count year yearSqr
## 1     5    0       0
## 2     3    1       1
## 3     0    2       4
## 4     2    3       9
## 5     0    4      16
## 6     3    5      25
```


---

# GLM: datos de conteo con sobredispersión

Exploremos la que ahora será nuestra variable explicativa:


```r
hist(disc$count)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-22-1.png" width="400" style="display: block; margin: auto;" /&gt;

---


```r
mod3 = glm(count ~ year + yearSqr, family = "poisson", data = disc)
summary(mod3)
```

```
## 
## Call:
## glm(formula = count ~ year + yearSqr, family = "poisson", data = disc)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.9066  -0.8397  -0.2544   0.4776   3.3303  
## 
## Coefficients:
##               Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)  7.592e-01  1.814e-01   4.186 2.84e-05 ***
## year         3.356e-02  8.499e-03   3.948 7.87e-05 ***
## yearSqr     -4.106e-04  8.699e-05  -4.720 2.35e-06 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for poisson family taken to be 1)
## 
##     Null deviance: 164.68  on 99  degrees of freedom
## Residual deviance: 132.84  on 97  degrees of freedom
## AIC: 407.85
## 
## Number of Fisher Scoring iterations: 5
```

---


```r
mod4 = glm(count ~ year + yearSqr, family = "quasipoisson", data = disc)
summary(mod4)
```

```
## 
## Call:
## glm(formula = count ~ year + yearSqr, family = "quasipoisson", 
##     data = disc)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.9066  -0.8397  -0.2544   0.4776   3.3303  
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)  0.7592473  0.2072715   3.663 0.000406 ***
## year         0.0335569  0.0097112   3.455 0.000816 ***
## yearSqr     -0.0004106  0.0000994  -4.131 7.66e-05 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for quasipoisson family taken to be 1.305649)
## 
##     Null deviance: 164.68  on 99  degrees of freedom
## Residual deviance: 132.84  on 97  degrees of freedom
## AIC: NA
## 
## Number of Fisher Scoring iterations: 5
```


---

# GLM: datos de conteo con sobredispersión

El parámetro de overdispersion ( `\(\phi\)` ) nos indica si una distribución quasipoisson es adecuada. Si `\(\phi &gt; 1\)`, entonces nos sugiere usa una quasipoisson, si `\(\phi &lt; 1\)`, una quasipoisson no es necesaria.

---

# GLM: datos de conteo con sobredispersión

Revisamos los residuos:


```r
qqnorm(qresid(mod4))
qqline(qresid(mod4))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-25-1.png" width="400" style="display: block; margin: auto;" /&gt;

---


```r
mod5 = MASS::glm.nb(count ~ year + yearSqr, data = disc)
summary(mod5)
```

```
## 
## Call:
## MASS::glm.nb(formula = count ~ year + yearSqr, data = disc, init.theta = 11.53157519, 
##     link = log)
## 
## Deviance Residuals: 
##     Min       1Q   Median       3Q      Max  
## -2.6849  -0.7707  -0.2344   0.4232   2.7134  
## 
## Coefficients:
##               Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept)  7.526e-01  2.019e-01   3.727 0.000194 ***
## year         3.386e-02  9.471e-03   3.575 0.000350 ***
## yearSqr     -4.132e-04  9.627e-05  -4.292 1.77e-05 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for Negative Binomial(11.5316) family taken to be 1)
## 
##     Null deviance: 131.91  on 99  degrees of freedom
## Residual deviance: 106.20  on 97  degrees of freedom
## AIC: 406.21
## 
## Number of Fisher Scoring iterations: 1
## 
## 
##               Theta:  11.53 
##           Std. Err.:  7.42 
## 
##  2 x log-likelihood:  -398.214
```

---

# GLM: datos de conteo con sobredispersión

Podemos decidir usar una distribución binomial negativa cuando, en un GLM Poisson, el ratio de Residual deviance/degrees of freedom es mayor a 1.

--

Revisamos los residuos:


```r
qqnorm(qresid(mod5))
qqline(qresid(mod5))
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-27-1.png" width="350" style="display: block; margin: auto;" /&gt;

---

# GLM: respuesta gamma

Dada nuestra base de datos:


```r
head(case1202)
```

```
##   Bsal Sal77  Sex Senior Age Educ Exper
## 1 5040 12420 Male     96 329   15  14.0
## 2 6300 12060 Male     82 357   15  72.0
## 3 6000 15120 Male     67 315   15  35.5
## 4 6000 16320 Male     97 354   12  24.0
## 5 6000 12300 Male     66 351   12  56.0
## 6 6840 10380 Male     92 374   15  41.5
```

---

# GLM: respuesta gamma

Modelo lineal para modelar `units` como la variable respuesta:


```r
mod6 = lm(Exper ~ Age, data=case1202)
summary(mod6)
```

```
## 
## Call:
## lm(formula = Exper ~ Age, data = case1202)
## 
## Residuals:
##      Min       1Q   Median       3Q      Max 
## -150.974  -21.633   -3.205   24.866  146.490 
## 
## Coefficients:
##               Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) -144.59165   20.26830  -7.134 2.28e-10 ***
## Age            0.51754    0.04099  12.626  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Residual standard error: 55.13 on 91 degrees of freedom
## Multiple R-squared:  0.6366,	Adjusted R-squared:  0.6326 
## F-statistic: 159.4 on 1 and 91 DF,  p-value: &lt; 2.2e-16
```

---

# GLM: respuesta gamma

Veamos los valores ajustados:


```r
plot_model(mod6, type = 'pred', show.data = TRUE)
```

```
## $Age
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-30-1.png" width="350" style="display: block; margin: auto;" /&gt;

---

# GLM: respuesta gamma

Exploremos la distribución de la variable respuesta:


```r
hist(case1202$Exper)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-31-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

# GLM: respuesta gamma

¿Qué alternativas tenemos?

--

Podemos implementar un GLM con respuesta gamma (solo valores positivos):


```r
mod7 = glm(Exper + 1 ~ Age, data = case1202, family = Gamma(link = "log"))
```

---


```r
summary(mod7)
```

```
## 
## Call:
## glm(formula = Exper + 1 ~ Age, family = Gamma(link = "log"), 
##     data = case1202)
## 
## Deviance Residuals: 
##      Min        1Q    Median        3Q       Max  
## -2.22397  -0.60604  -0.02406   0.34153   1.07844  
## 
## Coefficients:
##              Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept) 1.4770108  0.2118855   6.971 4.87e-10 ***
## Age         0.0060060  0.0004285  14.016  &lt; 2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## (Dispersion parameter for Gamma family taken to be 0.3321014)
## 
##     Null deviance: 101.471  on 92  degrees of freedom
## Residual deviance:  46.044  on 91  degrees of freedom
## AIC: 970.8
## 
## Number of Fisher Scoring iterations: 6
```

---

# GLM: respuesta gamma


```r
plot_model(mod7, type = 'pred', show.data = TRUE)
```

```
## $Age
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-34-1.png" width="400" style="display: block; margin: auto;" /&gt;

---

class: inverse, center, middle

# Modelos aditivos generalizados (GAM)

---

# GAM


Hay casos en donde la asociación lineal entre las variables no se cumple. Para casos donde no se tenga una relación lineal entre la variable respuesta y variables independientes, podemos utilizar un modelo aditivo generalizado:


`$$y \sim EDM(\mu, etc)$$`

`$$g(\mu) = \beta_0 + f(x_{1}) + f(x_{2}) + ... + f(x_{p})$$`

`$$E(y) \sim \mu$$`
--

Variables independientes ahora incorporan una función de suavizamiento (basis function, `\(f\)` ), lo que permite relaciones no lineales entre las variables.

---

Por ejemplo:

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-35-1.png" style="display: block; margin: auto;" /&gt;

---

¿Podríamos implementar un ANOVA o algún modelo lineal?

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-36-1.png" style="display: block; margin: auto;" /&gt;

---

Una función como esta nos puede ayudar mucho:

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-37-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="images/mcycleFigure-1.svg" width="700" style="display: block; margin: auto;" /&gt;

---

¿Qué es un nodo (knots)?

&lt;img src="images/piecewisePoly-1.svg" width="700" style="display: block; margin: auto;" /&gt;

--

A mayor cantidad de nodos, mejor ajuste (cuidado con oversmoothing!).

---

De una forma general:

`$$g(\mu) = \beta_0 + f(x_{1}) + f(x_{2}) + ... + f(x_{p})$$`

--

Luego:

`$$f(x_1) = \beta_0 + \beta_1x^1 + ... + \beta_dx^d$$`
--

Podemos producir cualquier función polinomial!

---

# GAM en R


```r
library(mgcv)
```

```
## This is mgcv 1.8-33. For overview type 'help("mgcv-package")'.
```

```r
head(savings, n = 10)
```

```
##               sr pop15 pop75     dpi ddpi
## Australia  11.43 29.35  2.87 2329.68 2.87
## Austria    12.07 23.32  4.41 1507.99 3.93
## Belgium    13.17 23.80  4.43 2108.47 3.82
## Bolivia     5.75 41.89  1.67  189.13 0.22
## Brazil     12.88 42.19  0.83  728.47 4.56
## Canada      8.79 31.72  2.85 2982.88 2.43
## Chile       0.60 39.74  1.34  662.86 2.67
## China      11.90 44.75  0.67  289.52 6.51
## Colombia    4.98 46.64  1.06  276.65 3.08
## Costa Rica 10.78 47.64  1.14  471.24 2.80
```

---


```r
fit_gam = gam(sr ~ s(pop15) + s(pop75) + s(dpi) + s(ddpi), data=savings)
summary(fit_gam)
```

```
## 
## Family: gaussian 
## Link function: identity 
## 
## Formula:
## sr ~ s(pop15) + s(pop75) + s(dpi) + s(ddpi)
## 
## Parametric coefficients:
##             Estimate Std. Error t value Pr(&gt;|t|)    
## (Intercept)   9.6710     0.4816   20.08   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Approximate significance of smooth terms:
##            edf Ref.df     F p-value   
## s(pop15) 5.924  7.064 3.608 0.00406 **
## s(pop75) 1.350  1.623 2.811 0.06586 . 
## s(dpi)   1.000  1.000 0.168 0.68403   
## s(ddpi)  1.000  1.000 4.789 0.03455 * 
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## R-sq.(adj) =  0.422   Deviance explained = 53.2%
## GCV = 14.593  Scale est. = 11.595    n = 50
```

---

# GAM en R

Aquí hay algunos términos nuevos:

* **edf**: effective degrees of freedom. Es un resultados de la penalidad aplicada al grado de suavizamiento (detalles estadísticos en bibliografía!). Evita un over-suavizamiento o under-suavizamiento. Puede interpretarse como el nivel de suavizamiento aplicado a una variable.

* **GCV**: generalized cross validation. Es un proxy del error de predicción cuadrático medio (mean square prediction error). Esto se basa en un método llamado *leave-one-out cross validation*. Utilizado para comparar modelos (similar a *AIC*), donde el modelo con menor *GCV* es el mejor.

* **Deviance explained**: es una generalización del `\(R^2\)` (sin ajustar).

* **Scale est.**: equivalente a la suma de cuadrado de los residuales.

---


```r
plot(fit_gam, pages=1)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-42-1.png" style="display: block; margin: auto;" /&gt;

---

También podemos observarlo en escala de las variable respuesta:


```r
plot(ggeffects::ggpredict(fit_gam), facets = TRUE)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-43-1.png" style="display: block; margin: auto;" /&gt;

---

# GAM en R

Existen diferentes formas de suavizar una variable (smooth term), los cuales pueden ser explorados [aquí](https://stat.ethz.ch/R-manual/R-devel/library/mgcv/html/smooth.terms.html). El método por defecto es: thin plate regression splines (funciona bien en la mayoría de los casos) `bs = "tp"`.

---

También debemos revisar los supuestos de un GAM. Distribución de residuales:


```r
par(mfrow = c(2,2))
gam.check(fit_gam)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-44-1.png" style="display: block; margin: auto;" /&gt;

```
## 
## Method: GCV   Optimizer: magic
## Smoothing parameter selection converged after 33 iterations.
## The RMS GCV score gradient at convergence was 6.545033e-07 .
## The Hessian was positive definite.
## Model rank =  37 / 37 
## 
## Basis dimension (k) checking results. Low p-value (k-index&lt;1) may
## indicate that k is too low, especially if edf is close to k'.
## 
##            k'  edf k-index p-value
## s(pop15) 9.00 5.92    1.18    0.88
## s(pop75) 9.00 1.35    1.11    0.69
## s(dpi)   9.00 1.00    0.92    0.28
## s(ddpi)  9.00 1.00    1.10    0.72
```

---

# GAM en R: respuesta binomial

Hasta el momento hemos visto una respuesta Gaussiana (normal) con una función link igual a la identidad (`identity`). En GAMs también podemos incorporar diferentes familias:

--


```r
cricketer = read.csv('cricketr.csv')
cricketer$hand = NA
cricketer$hand = ifelse(test = cricketer$left == 'left', yes = 1, no = 0)
head(cricketer)
```

```
##    left year life dead acd kia inbed cause hand
## 1 right 1890  102    0   0   0     0 alive    0
## 2  left 1892  100    0   0   0     0 alive    1
## 3 right 1893   99    0   0   0     0 alive    0
## 4 right 1894   98    0   0   0     0 alive    0
## 5 right 1896   96    0   0   0     0 alive    0
## 6 right 1896   96    0   0   0     0 alive    0
```

---

Para implementar el modelo:


```r
hand.gam = gam(hand ~ s(year), data=cricketer, family=binomial)
summary(hand.gam)
```

```
## 
## Family: binomial 
## Link function: logit 
## 
## Formula:
## hand ~ s(year)
## 
## Parametric coefficients:
##             Estimate Std. Error z value Pr(&gt;|z|)    
## (Intercept) -1.49285    0.03361  -44.41   &lt;2e-16 ***
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## Approximate significance of smooth terms:
##           edf Ref.df Chi.sq p-value   
## s(year) 7.873  8.664  23.87  0.0066 **
## ---
## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
## 
## R-sq.(adj) =  0.00301   Deviance explained = 0.472%
## UBRE = -0.044557  Scale est. = 1         n = 5960
```

---

Revisamos los efectos:


```r
plot(ggeffects::ggpredict(hand.gam), facets = TRUE)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-47-1.png" style="display: block; margin: auto;" /&gt;

---

# GAM en R: respuesta Poisson

Podemos transformar los datos de la siguiente forma:


```r
rtlef = data.frame(with(cricketer, as(table(year, left),"matrix")))
rtlef$year = as.numeric(rownames(rtlef))
head(rtlef)
```

```
##      left right year
## 1840    1     6 1840
## 1841    4    16 1841
## 1842    5    16 1842
## 1843    3    25 1843
## 1844    4    25 1844
## 1845    2    24 1845
```

--

Luego:


```r
hand.gam2 = gam(left ~ s(year), data=rtlef, family=poisson)
```

---


```r
plot(ggeffects::ggpredict(hand.gam2), facets = TRUE)
```

&lt;img src="Clase_5_files/figure-html/unnamed-chunk-50-1.png" style="display: block; margin: auto;" /&gt;

---

# GAM en R: respuesta Poisson

Podemos también extraer los datos predichos por el modelo:


```r
predict(hand.gam2, type="response")[1:20]
```

```
##     1840     1841     1842     1843     1844     1845     1846     1847 
## 2.742999 2.893250 3.051389 3.217269 3.390486 3.570406 3.756216 3.946975 
##     1848     1849     1850     1851     1852     1853     1854     1855 
## 4.141688 4.339378 4.539171 4.740365 4.942502 5.145408 5.349228 5.554421 
##     1856     1857     1858     1859 
## 5.761740 5.972184 6.186925 6.407220
```

---

class: inverse, center, middle

# Gracias!

Contacto: [**cursos@cousteau-group.com**](mailto:cursos@cousteau-group.com)

&lt;img src="LOGO05.png" width="450" style="display: block; margin: auto;" /&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
